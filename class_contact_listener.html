<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Jolt Physics: ContactListener Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="LogoSmall.png"/></td>
  <td id="projectalign">
   <div id="projectname">Jolt Physics
   </div>
   <div id="projectbrief">A multi core friendly Game Physics Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_contact_listener.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_contact_listener-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ContactListener Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_contact_listener_8h_source.html">ContactListener.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a577b31dbf6d6e5a6ada2864a0b3f70bd" id="r_a577b31dbf6d6e5a6ada2864a0b3f70bd"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a577b31dbf6d6e5a6ada2864a0b3f70bd">~ContactListener</a> ()=default</td></tr>
<tr class="memdesc:a577b31dbf6d6e5a6ada2864a0b3f70bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure virtual destructor.  <br /></td></tr>
<tr class="separator:a577b31dbf6d6e5a6ada2864a0b3f70bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb704483e4e1f2eba7109b504afdf482" id="r_abb704483e4e1f2eba7109b504afdf482"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="_contact_listener_8h.html#a996dd20903cf7428fc11a70e8676b93c">ValidateResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb704483e4e1f2eba7109b504afdf482">OnContactValidate</a> (const <a class="el" href="class_body.html">Body</a> &amp;inBody1, const <a class="el" href="class_body.html">Body</a> &amp;inBody2, <a class="el" href="_real_8h.html#a43bea2d9c57780b4b66bab1312fd77f3">RVec3Arg</a> inBaseOffset, const <a class="el" href="class_collide_shape_result.html">CollideShapeResult</a> &amp;inCollisionResult)</td></tr>
<tr class="separator:abb704483e4e1f2eba7109b504afdf482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1d7908c8556ce24448ac572d7ad944" id="r_aeb1d7908c8556ce24448ac572d7ad944"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb1d7908c8556ce24448ac572d7ad944">OnContactAdded</a> (const <a class="el" href="class_body.html">Body</a> &amp;inBody1, const <a class="el" href="class_body.html">Body</a> &amp;inBody2, const <a class="el" href="class_contact_manifold.html">ContactManifold</a> &amp;inManifold, <a class="el" href="class_contact_settings.html">ContactSettings</a> &amp;ioSettings)</td></tr>
<tr class="separator:aeb1d7908c8556ce24448ac572d7ad944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11e4d0107c2764e1c7e04eef72cb404" id="r_aa11e4d0107c2764e1c7e04eef72cb404"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa11e4d0107c2764e1c7e04eef72cb404">OnContactPersisted</a> (const <a class="el" href="class_body.html">Body</a> &amp;inBody1, const <a class="el" href="class_body.html">Body</a> &amp;inBody2, const <a class="el" href="class_contact_manifold.html">ContactManifold</a> &amp;inManifold, <a class="el" href="class_contact_settings.html">ContactSettings</a> &amp;ioSettings)</td></tr>
<tr class="separator:aa11e4d0107c2764e1c7e04eef72cb404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef8f0cac1d560622743420afcd1ce17a" id="r_aef8f0cac1d560622743420afcd1ce17a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef8f0cac1d560622743420afcd1ce17a">OnContactRemoved</a> (const <a class="el" href="class_sub_shape_i_d_pair.html">SubShapeIDPair</a> &amp;inSubShapePair)</td></tr>
<tr class="separator:aef8f0cac1d560622743420afcd1ce17a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A listener class that receives collision contact events. It can be registered through <a class="el" href="class_physics_system.html#ade7967ad5ff4a67d255cc6fb956943c8">PhysicsSystem::SetContactListener</a>. Only a single contact listener can be registered. A common pattern is to create a contact listener that casts <a class="el" href="class_body.html#a48b9455aae90fe4d73302389f6c7d9b5" title="Access to the user data, can be used for anything by the application.">Body::GetUserData</a> to a game object and then forwards the call to a handler specific for that game object. Typically this is done on both objects involved in a collision event.</p>
<p>Note that contact listener callbacks are called from multiple threads at the same time when all bodies are locked, this means you cannot use <a class="el" href="class_physics_system.html#a35474557b977d2a03e7b5e7c920bf2ee" title="Access to the body interface. This interface allows to to create / remove bodies and to change their ...">PhysicsSystem::GetBodyInterface</a> / <a class="el" href="class_physics_system.html#a3ec396058f674026726e59dc7ad20609" title="Returns a locking interface that locks the body so other threads cannot modify it.">PhysicsSystem::GetBodyLockInterface</a> but must use <a class="el" href="class_physics_system.html#a55216f4cfc718d052548baac4ba098d7" title="Version that does not lock the bodies, use with great care!">PhysicsSystem::GetBodyInterfaceNoLock</a> / <a class="el" href="class_physics_system.html#ad381ea5bd5568b20ae05c1229dbff49e" title="Returns a locking interface that won&#39;t actually lock the body. Use with great care!">PhysicsSystem::GetBodyLockInterfaceNoLock</a> instead. If you use a locking interface, the simulation will deadlock. You're only allowed to read from the bodies and you can't change physics state. During OnContactRemoved you cannot access the bodies at all, see the comments at that function.</p>
<p>While a callback can come from multiple threads, all callbacks relating to a single body pair are serialized. For <a class="el" href="_motion_quality_8h.html#af43db3453103c2e62526f54dd8542d3aa4984667940802dedc139aa7a430a6553">EMotionQuality::Discrete</a> bodies, during every 'collision step' in a <a class="el" href="class_physics_system.html#a4cdc76b2486dfaecfc9319d040e5e5f3">PhysicsSystem::Update</a>, you will receive at most one OnContactAdded/Persisted/Removed call per body/sub shape pair. For <a class="el" href="_motion_quality_8h.html#af43db3453103c2e62526f54dd8542d3aa38f63d197afcc4a4965d98f9401c36e0">EMotionQuality::LinearCast</a> bodies, you may get an OnContactAdded followed by an OnContactPersisted for the same body/sub shape pair. This happens when a body collides both in the discrete and the continuous collision detection stage. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a577b31dbf6d6e5a6ada2864a0b3f70bd" name="a577b31dbf6d6e5a6ada2864a0b3f70bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577b31dbf6d6e5a6ada2864a0b3f70bd">&#9670;&#160;</a></span>~ContactListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ContactListener::~ContactListener </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ensure virtual destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aeb1d7908c8556ce24448ac572d7ad944" name="aeb1d7908c8556ce24448ac572d7ad944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb1d7908c8556ce24448ac572d7ad944">&#9670;&#160;</a></span>OnContactAdded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ContactListener::OnContactAdded </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_body.html">Body</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inBody1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_body.html">Body</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inBody2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_contact_manifold.html">ContactManifold</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inManifold</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_contact_settings.html">ContactSettings</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ioSettings</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a new contact point is detected.</p>
<p>Note that this callback is called when all bodies are locked, so don't use any locking functions! See detailed class description of <a class="el" href="class_contact_listener.html">ContactListener</a>.</p>
<p><a class="el" href="class_body.html">Body</a> 1 and 2 will be sorted such that body 1 ID &lt; body 2 ID, so body 1 may not be dynamic.</p>
<p>Note that only active bodies will report contacts, as soon as a body goes to sleep the contacts between that body and all other bodies will receive an OnContactRemoved callback, if this is the case then <a class="el" href="class_body.html#aa3c98e271056d300e6a5a5cf4783e61e" title="If this body is currently actively simulating (true) or sleeping (false)">Body::IsActive()</a> will return false during the callback.</p>
<p>When contacts are added, the constraint solver has not run yet, so the collision impulse is unknown at that point. The velocities of inBody1 and inBody2 are the velocities before the contact has been resolved, so you can use this to estimate the collision impulse to e.g. determine the volume of the impact sound to play (see: EstimateCollisionResponse). </p>

</div>
</div>
<a id="aa11e4d0107c2764e1c7e04eef72cb404" name="aa11e4d0107c2764e1c7e04eef72cb404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11e4d0107c2764e1c7e04eef72cb404">&#9670;&#160;</a></span>OnContactPersisted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ContactListener::OnContactPersisted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_body.html">Body</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inBody1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_body.html">Body</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inBody2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_contact_manifold.html">ContactManifold</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inManifold</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_contact_settings.html">ContactSettings</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ioSettings</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a contact is detected that was also detected last update.</p>
<p>Note that this callback is called when all bodies are locked, so don't use any locking functions! See detailed class description of <a class="el" href="class_contact_listener.html">ContactListener</a>.</p>
<p><a class="el" href="class_body.html">Body</a> 1 and 2 will be sorted such that body 1 ID &lt; body 2 ID, so body 1 may not be dynamic.</p>
<p>If the structure of the shape of a body changes between simulation steps (e.g. by adding/removing a child shape of a compound shape), it is possible that the same sub shape ID used to identify the removed child shape is now reused for a different child shape. The physics system cannot detect this, so may send a 'contact persisted' callback even though the contact is now on a different child shape. You can detect this by keeping the old shape (before adding/removing a part) around until the next <a class="el" href="class_physics_system.html#a4cdc76b2486dfaecfc9319d040e5e5f3">PhysicsSystem::Update</a> (when the OnContactPersisted callbacks are triggered) and resolving the sub shape ID against both the old and new shape to see if they still refer to the same child shape. </p>

</div>
</div>
<a id="aef8f0cac1d560622743420afcd1ce17a" name="aef8f0cac1d560622743420afcd1ce17a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef8f0cac1d560622743420afcd1ce17a">&#9670;&#160;</a></span>OnContactRemoved()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ContactListener::OnContactRemoved </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sub_shape_i_d_pair.html">SubShapeIDPair</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inSubShapePair</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called whenever a contact was detected last update but is not detected anymore.</p>
<p>You cannot access the bodies at the time of this callback because:</p><ul>
<li>All bodies are locked at the time of this callback.</li>
<li>Some properties of the bodies are being modified from another thread at the same time.</li>
<li>The body may have been removed and destroyed (you'll receive an OnContactRemoved callback in the <a class="el" href="class_physics_system.html#a4cdc76b2486dfaecfc9319d040e5e5f3">PhysicsSystem::Update</a> after the body has been removed).</li>
</ul>
<p>Cache what you need in the OnContactAdded and OnContactPersisted callbacks and store it in a separate structure to use during this callback. Alternatively, you could just record that the contact was removed and process it after <a class="el" href="class_physics_system.html#a4cdc76b2486dfaecfc9319d040e5e5f3">PhysicsSystem::Update</a>.</p>
<p><a class="el" href="class_body.html">Body</a> 1 and 2 will be sorted such that body 1 ID &lt; body 2 ID, so body 1 may not be dynamic.</p>
<p>The sub shape IDs were created in the previous simulation step, so if the structure of a shape changes (e.g. by adding/removing a child shape of a compound shape), the sub shape ID may not be valid / may not point to the same sub shape anymore. If you want to know if this is the last contact between the two bodies, use <a class="el" href="class_physics_system.html#ad8f5849a90549504d9f1705c324a9a83">PhysicsSystem::WereBodiesInContact</a>. </p>

</div>
</div>
<a id="abb704483e4e1f2eba7109b504afdf482" name="abb704483e4e1f2eba7109b504afdf482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb704483e4e1f2eba7109b504afdf482">&#9670;&#160;</a></span>OnContactValidate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="_contact_listener_8h.html#a996dd20903cf7428fc11a70e8676b93c">ValidateResult</a> ContactListener::OnContactValidate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_body.html">Body</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inBody1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_body.html">Body</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inBody2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_real_8h.html#a43bea2d9c57780b4b66bab1312fd77f3">RVec3Arg</a></td>          <td class="paramname"><span class="paramname"><em>inBaseOffset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_collide_shape_result.html">CollideShapeResult</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inCollisionResult</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after detecting a collision between a body pair, but before calling OnContactAdded and before adding the contact constraint. If the function rejects the contact, the contact will not be processed by the simulation. This is a rather expensive time to reject a contact point since a lot of the collision detection has happened already, make sure you filter out the majority of undesired body pairs through the <a class="el" href="class_object_layer_pair_filter.html" title="Filter class to test if two objects can collide based on their object layer. Used while finding colli...">ObjectLayerPairFilter</a> that is registered on the <a class="el" href="class_physics_system.html">PhysicsSystem</a>.</p>
<p>This function may not be called again the next update if a contact persists and no new contact pairs between sub shapes are found.</p>
<p>Note that this callback is called when all bodies are locked, so don't use any locking functions! See detailed class description of <a class="el" href="class_contact_listener.html">ContactListener</a>.</p>
<p><a class="el" href="class_body.html">Body</a> 1 will have a motion type that is larger or equal than body 2's motion type (order from large to small: dynamic -&gt; kinematic -&gt; static). When motion types are equal, they are ordered by <a class="el" href="class_body_i_d.html" title="ID of a body. This is a way of reasoning about bodies in a multithreaded simulation while avoiding ra...">BodyID</a>.</p>
<p>The collision result (inCollisionResult) is reported relative to inBaseOffset. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Jolt/Physics/Collision/<a class="el" href="_contact_listener_8h_source.html">ContactListener.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_contact_listener.html">ContactListener</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
